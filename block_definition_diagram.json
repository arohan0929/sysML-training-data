{
    "nodes": [
        {
            "name": "Block Definition Diagram",
            "abbreviation": "bdd",
            "description": "Block definition diagrams display all of the model elements in your system. These can include blocks, actors, value types, constraint blocks, flow specifications, and interfaces. These elements are known as elements of definition and the relationships between the elements can be displayed with associations, generalizations, and dependencies, these are called structural relationships.",
            "purpose": "The purpose of Block Definition Diagrams is to specify system static structures that be used for Control Objects, Data Objects, and Interface Objects. When properly applied Block diagrams are recursively scalable and mathematically (parametrically) simulatable.",
        },
        {
            "model elements": [
        {
            "name": "block",
            "description": "A block is the basic unit of structure in SysML. You can use a block to model any type of entity within your system of interest or in the system's external environment. Note the distinction between definition and instantiation (which SysML refers to as “usage”). This distinction is one of the most fundamental system design concepts, and it's a pattern that recurs often in SysML. Some kinds of model elements (e.g., blocks, value types, constraint blocks) represent definitions of types; other kinds of model elements (e.g., part properties, value properties, constraint properties) represent instances of those types. By analogy, a blueprint of a house is a definition of a type of house; each house a developer builds on a plot of land in accordance with that blueprint is a distinct instance of that type. With that in mind, I reiterate: A block represents a type of entity, and not an instance. For example, you could create a block named DesktopWorkstation in your system model. That block would represent a type that defines a set of properties—such as monitor, keyboard, mouse, CPU, manufacturer, disk space, cost—that are common to all instances. Each desktop workstation that your IT department purchases for each office and cubicle would be a distinct instance of that DesktopWorkstation block. You can easily tell the difference between elements of definition and elements of usage in a system model. Elements of definition have a name only (e.g., DesktopWorkstation); elements of usage have a name and a type, separated by a colon (e.g., SDX1205LJD : DesktopWorkstation). The notation for a block is a rectangle with the stereotype «block» preceding the name in the name compartment. You're required to display a block's name compartment. Often you'll display additional optional compartments that convey the features of the block. Features come in two varieties: structural features (also known as properties) and behavioral features. Here are the optional compartments that you can display: Parts, References, Values, Constraints, Operations, Receptions, Standard ports (in SysML v1.2 and earlier), Flow ports (in SysML v1.2 and earlier), Full ports (in SysML v1.3), Proxy ports (in SysML v1.3), Flow properties (in SysML v1.3), and Structure. The structure compartment is the only compartment that doesn't list features. Rather, it's a graphical compartment that displays a block's internal structure; you can display in that compartment all the same notations you can display on an internal block diagram (IBD). Modelers rarely display this compartment. Note that even though it's legal to display a block's ports in compartments, it's much more common to display ports as small squares that straddle the border of a block",
            "structural features": [
                {
                    "name": "part property",
                    "description": "Part properties are listed in the parts compartment of a block. A part property represents a structure that’s internal to a block. Stated differently, a block is composed of its part properties. This relationship conveys ownership. However, SysML stops short of defining the word ownership; this concept has different meanings in different domains. In the hardware domain, ownership typically refers to physical composition. But SysML states definitively that ownership means that a part property can belong to only one composite structure at a time. However, a part property can be removed from one instance of a composite structure and added to another. For example, I can install a given antenna on only one satellite at a time, and not on two or more simultaneously. But that antenna can be removed from one satellite and reinstalled on another at some point. When you list a part property in the parts compartment of a block, it appears as a string with the following format: <part name> : <type> [<multiplicity>]. The part name is modeler defined. The type generally is the name of a block that you’ve created somewhere in the system model. The multiplicity is a constraint on the number of instances that the part property can represent within the composite, expressed either as a single integer or as a range of integers. If you want a part property to represent an unconstrained number of instances, you can set the multiplicity to 0..*. The asterisk means that there’s no upper bound (or more precisely, that you’re not specifying an upper bound in the system model). You would read 0..* in English as “zero or more.” Alternatively, you can set the multiplicity to *, a shorthand notation for 0..*. If no multiplicity is shown for a part property, the default is 1 (which is equivalent to 1..1). Note that 1 is almost always the default multiplicity in SysML. When a part property has a multiplicity with an upper bound greater than 1 (e.g., 1..2, 0..10, *), we refer to that part property as a collection (of instances). The key idea is that part property and instance are not synonyms; a single part property may potentially represent multiple instances within a composite if its specified multiplicity allows it.",
                    "examples": [
                        "pss : Power Subsystem [1]",
                        "backupComputer : Navigation Computer [1..3]"
                    ]
                },
                {
                    "name": "reference property",
                    "description": "Reference properties are listed in the references compartment of a block. A reference property represents a structure that’s external to a block.Unlike a part property, a reference property does not convey ownership. A reference property can roughly be described as a “needs” relationship; a block with a reference property needs that external structure for some purpose, either to provide a service or to exchange matter, energy, or data. And this implies that some type of connection must exist between them. Note that the presence of a reference property in a block does not by itself convey its purpose. If you need to convey that purpose, you could do so on an internal block diagram (IBD). When you list a reference property in the references compartment of a block, it appears as a string with the following format: <reference name> : <type> [<multiplicity>]. The reference name is modeler defined. The type must be the name of a block or actor that you’ve created somewhere in the system model. The multiplicity is a constraint on the number of instances that the reference property can represent. Like a part property, a reference property’s default multiplicity is 1 (if no multiplicity is shown). And like a part property, a reference property is referred to as a collection when its multiplicity has an upper bound greater than 1.",
                    "examples": [
                        "pss : Power Subsystem [1]",
                        "rcs : Radio Communication Subsystem [1]"
                    ]
                },
                {
                    "name": "value property",
                    "description": "Value properties are listed in the values compartment of a block. A value property can represent a quantity (of some type), a Boolean, or a string. Most often, though, a value property is something you can assign a number to. Value properties are particularly useful in conjunction with constraint properties to construct a mathematical model of your system. When you list a value property in the values compartment of a block, it appears as a string with the following format: <value name> : <type> [<multiplicity>] = <default value> The value name is modeler defined. The type must be the name of a value type that you’ve created somewhere in the system model. The multiplicity is a constraint on the number of values that the value property can hold. The default value is an optional piece of information; it represents the value assigned to the value property when an instance of its owning block first gets created. As with a part property and a reference property, a value property’s default multiplicity is 1 (if no multiplicity is shown). Similarly, a value property is referred to as a collection when its multiplicity has an upper bound greater than 1. Some value properties hold values that are assigned, and others hold values that are derived (calculated) from other value properties in the system model. To convey that a value property is derived, you put a forward slash (/) in front of its name.",
                    "examples": [
                        "/period : min",
                        "depth : km",
                        "times : Timestamp[0..*]"
                    ]
                },
                {
                    "name": "constraint property",
                    "description": "Constraint properties are listed in the constraints compartment of a block. A constraint property generally represents a mathematical relationship (an equation or inequality) that is imposed on a set of value properties. This is a higher level of model fidelity than is required on most modeling projects. However, constraint properties are an essential part of constructing mathematical models of a system, which you display on parametric diagrams. f a block, it appears as a string with the following format: <constraint name> : <type> The constraint name is modeler defined. The type must be the name of a constraint block that you’ve created somewhere in the system model. A constraint block is simply a special kind of block—one that you create to encapsulate a reusable constraint expression. Most often, a constraint expression is an equation or an inequality. Note that you’re not required to use constraint blocks to impose mathematical relationships on value properties. It’s perfectly legal to specify a constraint expression directly in the constraints compartment of a block. You would do this when only one block needs that constraint expression (i.e., when you don’t intend to reuse it in multiple places). As a matter of best practice, though, I recommend that you always encapsulate equations and inequalities in constraint blocks; it enables reuse if the need arises. Meanwhile, keep in mind these key ideas: Blocks can own constraint properties (to constrain value properties). Constraint properties are typed by constraint blocks, which generally encapsulate mathematical relationships.",
                    "examples": [
                        "storageCapacity >= truckQuantity * 2"
                    ]
                },
                {
                    "ports": [
                        {
                            "name": "standard port",
                            "description": "A standard port models the services (behaviors) that a block provides or requires at an interaction point on its boundary. Most often, you display a standard port as a small square straddling the border of a block. Note that it’s legal to list a standard port as a string in the standard ports compartment, but this is an uncommon notation. A standard port can have a modeler-defined name (e.g., sp_cdhs, sp_eps) that is displayed as a string floating near the standard port (either inside or outside the block border). A standard port can have one or more types; the types are the interfaces you assign to it (e.g., Power Generation, Status Reporting). An interface, like a block, is an element of definition—one that defines a set of operations and receptions, a behavioral contract that clients and providers will conform to. You can display an interface on a BDD as a rectangle with the keyword «interface» preceding the name; you can display its operations and receptions in the second and third compartments. When you assign an interface to a standard port, you assign it either as a provided interface or as a required interface. A provided interface is displayed using the ball notation—the lollipop symbol attached to the standard port. A block that provides an interface must implement all of the interface’s operations and receptions. A required interface is displayed using the socket notation—the stick with a semicircle attached to the standard port. A block that requires an interface may invoke one or more—but not necessarily all—of its operations or receptions at some point during system operation. Modeling with standard ports and interfaces is a way to decouple clients and providers, enabling you to design to abstractions rather than specific implementations. This extensibility lets you add new providers of interfaces at any time without impacting the existing clients of those interfaces."
                        },
                        {
                            "name": "flow port",
                            "description": "A flow port models the types of matter, energy, or data that can flow in or out of a block at an interaction point on its boundary. As with a standard port, you most often display a flow port as a small square straddling the border of a block. Unlike a standard port, however, a flow port has a symbol shown inside the small square (more on that soon). It’s legal to list a flow port as a string in a compartment—one named “flow ports”—but again, this is an uncommon notation. A flow port can have a modeler-defined name (e.g., dataOut, dataIn); it can also have a type (e.g., Housekeeping Data). The name and type are displayed as a string floating near the flow port, separated by a colon in the format name : type. The type that you specify for a flow port and the symbol that appears inside the square depend on the kind of flow port you’re modeling. SysML offers two kinds of flow ports: nonatomic flow ports and atomic flow ports. You add a nonatomic flow port (symbolized as < >) to a block when you need to model multiple types of items that could flow in or out via that port. The type of a nonatomic flow port must be the name of a flow specification that you’ve created somewhere in the system model. Like a block, a flow specification is an element of definition—one that defines a set of flow properties that can flow in or out of a nonatomic flow port. You can display a flow specification on a BDD as a rectangle with the stereotype «flowSpecification» preceding the name; you can display its flow properties in a compartment named flowProperties. A flow property represents a specific item that can flow in or out of a block via a flow port. Each flow property has a direction, a name, and a type, which are displayed as a string in the following format: <direction> <name> : <type> The direction can be in, out, or inout. The name is modeler defined. The type must be the name of a value type, block, or signal that you’ve created somewhere in your model hierarchy. The other kind of flow port is an atomic flow port. You add an atomic flow port to a block when you need to model a single type of item that could flow in or out via that port. The symbol inside the small square is an arrow that conveys the direction of flow. The type of an atomic flow port must be the name of a value type, block, or signal that you’ve created somewhere in your model hierarchy"
                        }
                    ]
                } 
            ],
            "behavioral features": [
                {
                    "name": "operations",
                    "description": "An operation represents a behavior that a block performs when a client calls it. Stated formally, an operation is invoked by a call event. Most often, an operation represents a synchronous behavior. This means that the caller waits for the behavior to complete before continuing with its own execution. However, SysML doesn't require this; you're free to represent any behavior as an operation - even when the caller doesn't wait for it to complete. You can display an opertaion on a BDD as a string in the operations compartment of a block. That string has the following format: <operation name> ( < parameter list> ) : <return type> [<multiplicity>]. The operation name is modeler defined. The parameter list is a comma-separated list of zero or more parameters. The return type (if any) must be the nae of a value type or block that you've created somewhere in your system model. The multiplicity is a constraint on the number of instances of the return type that the operation can return to the caller when it completes. The parameters in the parameter list represent the inputs or outputs of the operation. Each parameter in the list is displayed with the following format: <direction> <parameter name> : <type> [<multiplicity>] = <defualt value>. The direction can be in, out, or inout. The parameter name is modeler defined. The type must be the name of a value type or block that exists somewhere in your model. The multiplicity is a constraint on the number of instances of the type that the parameter can represent. The default value is the value assigned to the parameter if no value is specified as an argument when the operation is called. It is best practice to always use verb phrases (such as processCommand) to name an operation; an operation represents a behavior after all. Also, don't go overboard with parameter lists; simply adding operations to blocks (without specifying parameters) is often a sufficient degree of model fidelity. If you need to specify parameters for operations within the system model, be judicious about which ones you choose to display on any given BDD; the complete string for an operation could take up a lot of real estate on a BDD if you display even a few parameters."
                },
                {
                    "name": "receptions",
                    "description": "A reception represents a behavior that a block performs when a client sends a signal that triggers it. Stated formally, is invoked by a signal event. The key distinction between a reception and an operation is that a reception always represents an asynchronous behavior. This means that a client sends a signal - which triggers a reception upon receipt - and inmmediately continues with its own execution; it doesn't wait for the reception to complete (or even necessarily, to begin). Another key point is that a signal is itself a model element. You can use a signal to represent any type of matter, energy, or data that one part of a signal sends to another part - generally for the purpose of triggering a behavior on the receiving end. Like a block, a signal can own properties. Most often, those properties represent data that the signal carries from from a client to a target. And when the signal arrives at the target and triggers a reception, the signal's properties become inputs to that reception. A structure is an eligible target for a signal if it owns a reception that has the same name as the signal. Additionally, the reception must have a parameter with a compatible type for each property of the signal. When you display a reception in the receptions compartment of a block, the string has the following format: «signal» <reception name> ( <parameter list> ). The keyword «signal» must always precede the reception name. As mentioned earlier, the reception name must match the name of the signal in your model that triggers it. You can display as many parameters as necessary in the parameter list. Each parameter in the list is displayed with the following format: <parameter name> : <type> [<multiplicity>] = <default value>. The parameter name is modeler defined. The type must be the name of a value type or block that exists somewhere in your model.The multiplicity is a constraint on the number of instances of the type that the parameter can represent.   The default value is the value assigned to the parameter if no value is provided in the corresponding property of the signal. Unlike operations, receptions cannot have return types. Receptions are asynchronous; the client that sent the signal isn't waiting for a reply. For the same reason, the parameters of a reception can only be inputs and never outputs. "
                }
            ],
            "relationships": [
                {
                    "name": "reference assocations",
                    "description": "A reference association between two blocks means that a connection can exist between instances of those blocks in an operational system. And those instances can access each other for some purpose across the connection. The notation for a reference association on a BDD is a solid line between two blocks. An open arrowhead on exactly one end conveys unidirectional access; the absence of arrowheads on either end conveys bidirectional access. You can optionally display an association name floating near the middle of the line, and you can optionally display a role name and multiplicity on either end of the line. The association name is a modeler-defined string that describes the type of connection that can exist between instances of the two blocks. The role name shown on the end of a reference association corresponds to the name of a reference property—one that belongs to the block at the opposite end and whose type is the block that it's next to. Similarly, the multiplicity shown on the end of a reference association (near a role name) corresponds to the multiplicity of that same reference property. Sometimes a block has multiple reference properties of the same type.You can convey this equivalently by drawing multiple reference associations between the same two blocks. Each reference association represents a distinct reference property. Showing both notations on the same diagram is redundant. The choice to use the references compartment notation versus reference associations depends on how much information you need to expose on the BDD. Another factor in your decision is the need to specify a type for a connector on an IBD. If you intend to do this, then you need to create a reference association between two blocks and give it a name. The compartment notation would not meet your needs in this case."
                },
                {
                    "name": "composite associations",
                    "description": "A composite association between two blocks conveys structural decomposition. An instance of the block at the composite end is made up of some number of instances of the block at the part end. The notation for a composite association on a BDD is a solid line between two blocks with a solid diamond on the composite end. An open arrowhead on the part end of the line conveys unidirectional access from the composite to its part; the absence of an arrowhead conveys bidirectional access (i.e., the part will have a reference to the composite). The role name shown on the part end of a composite association corresponds to the name of a part property—one that's owned by the block at the composite end and whose type is the block at the part end. It’s redundant to show both the parts compartment notation and composite associations on the same diagram. The multiplicity on the part end of a composite association is not restricted; a composite structure can be made up of an arbitrary number of instances of parts—however many a system requires. However, the multiplicity on the composite end is restricted. A part—by definition—can belong to only one composite at a time. Therefore, the upper bound of the multiplicity on the composite end must always be 1. The lower bound of that multiplicity can be either 0 (zero) or 1. A lower bound of 0 conveys that a part can be removed from its composite structure; a lower bound of 1 conveys that it cannot be removed (it must be attached to a composite structure at all times in a valid instance of a system). You should use a composite association when you need to expose the features of the block that types a part; you should use compartment notation instead when those features are not the focus of the diagram."
                },
                {
                    "name": "generalizations",
                    "description": "A generalization is another kind of relationship you typically display on BDDs. This relationship conveys inheritance between two elements: a more generalized element, called the supertype, and a more specialized element, the subtype. You use generalizations to create classification trees (type hierarchies) in your system model. The notation for a generalization is a solid line with a hollow, triangular arrowhead on the end of the supertype. This relationship is read in English as “is a type of” going from the subtype to the supertype. When a supertype has more than one subtype shown on the same BDD, modelers often overlap the hollow, triangular arrowheads on the supertype end to conserve space on the diagram. A generalization conveys that a subtype inherits all the features of its supertype: the structural features (properties) and the behavioral features (operations and receptions). In addition to the features it inherits, a subtype may have other features that its supertype doesn’t have. For this reason, modelers often refer to a subtype as a specialization of its supertype. You create generalizations to define abstractions in your system design. A supertype is an abstraction of its subtypes; it factors out those features that are common among the subtypes. Abstractions let you define a common feature (such as the initialize operation) in one place within the model—in the supertype—and that common feature propagates down the type hierarchy to all the subtypes. Then, if you later need to change that common feature, you simply go back to that one place in the model to make the change, and all subtypes in the model get updated instantly. Abstraction is a powerful design principle; it conveys substitutability, meaning that a subtype will be accepted wherever its supertype is required. Building generalizations into your model can significantly reduce the time it takes to modify your system design as the life cycle progresses—and that capability directly translates into cost savings."
                },
                {
                    "name": "dependencies",
                    "description": "A dependency is the third kind of relationship you can display on BDDs. It means what it sounds like: One element in the model, the client, depends on another element in the model, the supplier. More precisely, a dependency conveys that when the supplier element changes, the client element may also have to change. Most often, you create a dependency between two model elements solely to establish traceability between them. A dependency relationship lets you use your modeling tool to perform automated downstream impact analysis when you make changes to your design. When you make a change to one element, you can query your modeling tool to generate a list of the other elements in the model that may be impacted by the change; the modeling tool navigates the set of dependencies that you’ve created between elements to generate that list. This is a practical reason to create dependencies in your model. However, you seldom have a reason to display them on BDDs. They are part of the structure of the model and not of the system that the model represents. And you will spend most of your time creating BDDs to convey system structure to your stakeholders. When a dependency appears on a BDD, the notation is a dashed line with an open arrowhead, which is drawn from the client to the supplier. Note that SysML defines specialized kinds of dependency relationships (e.g., package import, viewpoint conformance, and several kinds of requirements relationships). Although you rarely display dependencies on BDDs, you often display these specialized kinds of dependencies on package diagrams and requirements diagrams."
                }
            ]
        },
        {
            "name": "actor",
            "description": "An actor represents someone or something that has an external interface with your system. The name of an actor conveys a role played by a person, an organization, or another system when it interacts with your system. SysML defines two notations for an actor: a stick figure and a rectangle with the keyword «actor» preceding the name. Figure 3.24 shows examples of both notations. It’s legal to use either notation for any type of actor—person or system. However, modelers often adopt the convention of using the stick figure notation to represent a person and the rectangle notation to represent a system, although the language doesn't require it. You will occasionally display actors on BDDs to express the generalizations between actors and the associations between actors and blocks. It's far more common, though, to display actors on use case diagrams, where you express which use cases each actor participates in. All the key ideas about generalizations, reference associations, and composite associations also apply when actors are involved in these relationships. There are two constraints: You cannot define a generalization between an actor and a block, and an actor cannot have parts; that is, it cannot appear at the composite end of a composite association. (We always regard an actor as a black box.)"
        },
        {
            "value types": [
                {
                    "name": "primitive",
                    "description": "A primitive value type has no internal structure (it doesn’t own any value properties). Its notation is a rectangle with the stereotype «valueType» preceding the name. SysML defines four primitive value types: String, Boolean, Integer, and Real. You can, of course, define your own primitive value types as specializations (subtypes) of these four."
                },
                {
                    "name": "structured",
                    "description": "As its name implies, a structured value type has an internal structure—generally two or more value properties. As with a primitive value type, the notation for a structured value type is a rectangle with the stereotype «valueType» preceding the name. SysML defines one structured value type: Complex. Its structure consists of two value properties—realPart and imaginaryPart—that are both of type Real. One structured value type may, in turn, be the type of a value property within another structured value type. In this way, you can create arbitrarily complex systems of value types"
                },
                {
                    "name": "enumerated",
                    "description": "An enumerated value type—colloquially called an enumeration— simply defines a set of literals (legal values). If a parameter of an operation (or some other kind of element shown in the earlier bulleted list) is typed by an enumeration, then the value it holds at any moment must be one of the literals in that enumeration."
                }
            ]
        },
        {
            "name": "constraint block",
            "description": "Like a block, a constraint block is an element of definition—one that defines a Boolean constraint expression (an expression that must evaluate to either true or false). Most often, the constraint expression you define in a constraint block is an equation or an inequality: a mathematical relationship that you use to constrain value properties of blocks. You would do this for two reasons: To specify assertions about valid system values in an operational system or to perform engineering analyses during the design stage of the life cycle. The variables in a constraint expression are called constraint parameters. Generally, they represent quantities, and so they're typed most often by value types. Constraint parameters receive their values from the value properties they're bound to—that is, the value properties that are being constrained. At any given moment, those values either satisfy the constraint expression, or they don't; the system is either operating nominally, or it isn't. Note, however, that a BDD by itself can't convey which constraint parameters and value properties are bound to one another. You would express this piece of information on a parametric diagram. The notation for a constraint block on a BDD is a rectangle with the stereotype «constraint» preceding the name. The constraint expression always appears between curly brackets ({}) in the constraints compartment. The constraint parameters in the constraint expression are listed individually in the parameters compartment. You sometimes build a more complex constraint block from a set of simpler constraint blocks. You would do this to create a more complex mathematical relationship from simpler equations and inequalities. The more complex constraint block can display its constituent parts as a list of constraint properties in the constraints compartment. As an alternative to the constraints compartment notation, you can use composite associations to convey that one constraint block is composed of other, simpler ones.  These are equivalent notations. You use composite associations when you need to expose the details of the simpler constraint blocks; in contrast, you use the constraints compartment notation to hide those details when they're not the focus of the diagram."
        },
        {
            "name": "comment",
            "description": "SysML has a lot of rules (and they all exist to serve the very useful purpose of giving your design unambiguous meaning from one reader to the next). However, you sometimes need to express information on a diagram in an unconstrained way as a block of text. You can do this with a comment. A comment is, in fact, a model element. It consists of a single attribute: a string of text called the body. You can convey any information you need to in the body of a comment, and you can optionally attach a comment to other elements on a diagram to provide additional information about them. You can use comments on any of the nine kinds of SysML diagrams. The notation for a comment is commonly referred to as a note symbol: a rectangle whose upper-right corner is bent. You use a dashed line to attach a comment to other elements. If you need to, you can attach a comment to several model elements simultaneously by using a separate dashed line for each one.Modelers sometimes put freestanding comments with hyperlinks on a diagram to enable readers to quickly navigate to a related diagram in the model (or to an external document). To be clear, though, this capability is a function of the modeling tool you use; not all tools do this. And SysML itself says nothing about this capability. SysML defines some specialized kinds of comments: rationale, problem, and diagram description. These appear as a note symbol with the respective stereotype preceding the body of the comment. Modelers often use rationale comments in conjunction with requirements relationships and allocations."
        }
        ]
    },
    {
        "bestPracticesPatterns": [
        "Separate Control Objects, Interface Objects, and Data Objects through applying Object Triad Pattern techniques",
        "Nest block hierarchies by alternating between block definition diagrams and internal block diagrams",
        "All control-related activities should be explicitly assigned to Control Object blocks in your system model"
    ],
        "antiPatterns": [
        "Combine Control Object, Interface Object, and Data Object Blocks",
        "Creating Activity Diagrams that focus solely on the flow of functions without using partitions to show which Control Objects are responsible for managing the system's behavior",
        "Combining the syntax and meaning of Blocks and Activities"
    ]
    }
    ],
    "relationships": [
    {
      "type": "CONTAINS",
      "from": "Block Definition Diagram",
      "to": "model elements"
    },
    {
      "type": "CONTAINS",
      "from": "Block Definition Diagram",
      "to": "bestPracticesPatterns"
    },
    {
      "type": "CONTAINS",
      "from": "Block Definition Diagram",
      "to": "antiPatterns"
    }
  ]
}